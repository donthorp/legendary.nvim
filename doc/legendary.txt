*legendary.txt*                                  keymaps - commands - autocmds

==============================================================================
Table of Contents                                *legendary-table-of-contents*

1. Legendary                                             |legendary-legendary|
  - Features                                              |legendary-features|
  - Prerequisites                                    |legendary-prerequisites|
  - Installation                                      |legendary-installation|
  - Usage                                                    |legendary-usage|
  - Configuration                                    |legendary-configuration|
  - Table Structures                              |legendary-table-structures|
  - Lua API                                                |legendary-lua-api|
  - Utilities                                            |legendary-utilities|

==============================================================================
1. Legendary                                             *legendary-legendary*

Define your keymaps, commands, and autocommands as simple Lua tables, building
a legend at the same time.

FEATURES                                                  *legendary-features*


- Define your keymaps, commands, and `augroup`/`autocmd`s as simple Lua tables, then bind them with `legendary.nvim`
- Integration with which-key.nvim <https://github.com/folke/which-key.nvim>, use your existing `which-key.nvim` tables with `legendary.nvim`
- Uses `vim.ui.select()` so it can be hooked up to a fuzzy finder using something like dressing.nvim <https://github.com/stevearc/dressing.nvim> for a VS Code command palette like interface
- Execute normal and insert mode keymaps, commands, and autocommands, when you select them
- Help execute commands that take arguments by prefilling the command line instead of executing immediately
- Search built-in keymaps and commands along with your user-defined keymaps and commands (may be disabled in config). Notice some missing? Comment on this issue <https://github.com/mrjones2014/legendary.nvim/issues/1> or submit a PR!


PREREQUISITES                                        *legendary-prerequisites*


- Neovim nightly (0.7+), specifically, this plugin depends on the following APIs:
    - `vim.keymap.set`
    - `vim.api.nvim_create_augroup`
    - `vim.api.nvim_create_autocmd`
- (Optional) A good `vim.ui.select()` handler, this is what provides the UI for the finder.
    - I recommend telescope.nvim <https://github.com/nvim-telescope/telescope.nvim> paired with dressing.nvim <https://github.com/stevearc/dressing.nvim>.


INSTALLATION                                          *legendary-installation*

With `packer.nvim`:

>
    use({'mrjones2014/legendary.nvim'})
<


With `vim-plug`:

>
    Plug "mrjones2014/legendary.nvim"
<


USAGE                                                        *legendary-usage*

To trigger the finder for your configured keymaps, commands, and
`augroup`/`autocmd`s:

Lua:

>
    require('legendary').find() -- search keymaps, commands, and autocmds
    require('legendary').find('keymaps') -- search keymaps
    require('legendary').find('commands') -- search commands
    require('legendary').find('autocmds') -- search autocmds
<


Vim commands:

>
    :Legendary " search keymaps, commands, and autocmds
    :Legendary keymaps " search keymaps
    :Legendary commands " search commands
    :Legendary autocmds " search autocmds
<


CONFIGURATION                                        *legendary-configuration*

Default configuration is shown below. For detailed explanation of the structure
for keymap, command, and `augroup`/`autocmd` tables, see
|legendary-table-structures|.

>
    require('legendary').setup({
      -- Include builtins by default, set to false to disable
      include_builtin = true,
      -- Customize the prompt that appears on your vim.ui.select() handler
      select_prompt = 'Legendary',
      -- Initial keymaps to bind
      keymaps = {
        -- your keymap tables here
      },
      -- Initial commands to bind
      commands = {
        -- your command tables here
      },
      -- Initial augroups and autocmds to bind
      autocmds = {
        -- your autocmd tables here
      },
      -- Automatically add which-key tables to legendary
      -- see "which-key.nvim Integration" below for more details
      auto_register_which_key = true,
    })
<


`WHICH-KEY.NVIM` INTEGRATION ~

Already a `which-key.nvim` user? Use your existing `which-key.nvim` tables with
`legendary.nvim`!

>
    -- automatically register which-key.nvim tables with legendary.nvim
    -- when you register them with which-key.nvim.
    -- `setup()` must be called before `require('which-key).register()`
    require('legendary').setup()
    -- now this will register them with both which-key.nvim and legendary.nvim
    require('which-key').register(your_which_key_tables, your_which_key_opts)
    
    -- alternatively, if you'd prefer to manually register with legendary.nvim
    require('legendary').setup({ auto_register_which_key = false })
    require('which-key').register(your_which_key_tables, your_which_key_opts)
    require('legendary').bind_whichkey(your_which_key_tables, your_which_key_opts)
<


TABLE STRUCTURES                                  *legendary-table-structures*

The tables for keymaps, commands, and `augroup`/`autocmd`s are all similar. To
show up in the finder, you must include the `description` property.

Keymaps

For keymaps you are mapping yourself (as opposed to mappings set by other
plugins), the first two elements are the key and the handler, respectively. The
handler can be a command string like `:wa<CR>` or a Lua function. Example:

>
    local keymaps = {
      { '<leader>s', ':wa<CR>', description = 'Write all buffers', opts = {} },
      { '<leader>fm', vim.lsp.buf.formatting_sync, description = 'Format buffer with LSP' },
    }
<


If you need to pass parameters to the Lua function or call a function
dynamically from a plugin, you can use the following helper functions:

>
    local helpers = require('legendary.helpers')
    local keymaps = {
      { '<leader>p', helpers.lazy(vim.lsp.buf.formatting_sync, nil, 1500), description = 'Format with 1.5s timeout' },
      { '<leader>f', helpers.lazy_required_fn('telescope.builtin', 'oldfiles', { only_cwd = true }) }
    }
<


The keymapâ€™s mode defaults to normal (`n`), but you can set a different mode,
or list of modes, via the `mode` property:

>
    local keymaps = {
      { '<leader>c', ':CommentToggle<CR>', description = 'Toggle comment', mode = { 'n', 'v' } }
    }
<


You can also pass options to the keymap via the `opts` property, see `:h
vim.keymap.set` to see available options.

>
    local keymaps = {
      {
        '<leader>fm',
        vim.lsp.buf.formatting_sync,
        description = 'Format buffer with LSP',
        opts = { silent = true, noremap = true }
      },
    }
<


Finally, if you want to register keymaps with `legendary.nvim` in order to see
them in the finder, but not bind them (like for keymaps set by other plugins),
you can just omit the handler element:

>
    local keymaps = {
      { '<C-d>', description = 'Scroll docs up' },
      { '<C-f>', description = 'Scroll docs down' },
    }
<


Commands

Command tables follow the exact same structure as keymaps, but specify a
command name instead of a key code.

>
    local commands = {
      { ':DoSomething', ':echo "something"', description = 'Do something!' },
      { ':DoSomethingWithLua', require('some-module').some_method, description = 'Do something with Lua!' },
      -- a command from a plugin, don't specify a handler
      { ':CommentToggle', description = 'Toggle comment' },
    }
<


If you need a command to take an argument, specify `unfinished = true` to
pre-fill the command line instead of executing the command on selected. You can
put an argument name/hint in `[]` or `{}` that will be stripped when filling
the command line.

>
    local commands = {
      { ':MyCommand {some_argument}<CR>', description = 'Command with argument', unfinished = true },
      -- or
      { ':MyCommand [some_argument]<CR>', description = 'Command with argument', unfinished = true },
    }
<


<code>augroup</code>s and <code>autocmd</code>s

`augroup` tables are very simple. They have a `name` property, and a `clear`
property which defaults to `true`. This will clear the `augroup` when creating
it, equivalent to `au!`. `autocmd` tables nested within `augroup` tables will
automatically be defined in the `augroup`.

>
    local augroups = {
      {
        name = 'MyAugroupName',
        clear = true,
        -- you autocmd tables here
      }
    }
<


`autocmd` tables have an event or list of events, and a handler as the first
two elements, respectively. You can also specify options to be passed to the
`autocmd` via the `opts` property. The `opts` property defaults to `{ pattern =
'*', group = nil }`.

>
    local autocmds = {
      {
        'FileType',
        ':setlocal conceallevel=0',
        opts = {
          pattern = { 'json', 'jsonc' },
        },
      },
      {
        { 'BufRead', 'BufNewFile' },
        ':set filetype=jsonc',
        opts = {
          pattern = { '*.jsonc', 'tsconfig*.json' },
        },
      },
      {
        'BufWritePre',
        vim.lsp.buf.formatting_sync,
        -- include a description to execute it
        -- like a command on-demand from the finder
        description = 'Format on write with LSP',
      },
    }
<


An example putting both together:

>
    local augroups = {
      {
        name = 'LspOnAttachAutocmds',
        clear = true,
        {
          'BufWritePre',
          require('lsp.utils').format_document,
        },
        {
          'CursorHold',
          vim.diagnostic.open_float,
        },
      },
      {
        { 'BufRead', 'BufNewFile' },
        ':set filetype=jsonc',
        opts = {
          -- you can also manually add an autocmd
          -- to an existing augroup
          group = 'filetypedetect',
          pattern = { '*.jsonc', 'tsconfig*.json' },
        },
      }
    }
<


LUA API                                                    *legendary-lua-api*

You can also manually bind new items after youâ€™ve already called
`require('legendary').setup()`. This can be useful for things like binding
language-specific keyaps in the LSP `on_attach` function.

The following API functions are available:

>
    -- bind a single keymap
    require('legendary').bind_keymap(keymap)
    -- bind a list of keymaps
    require('legendary').bind_keymaps({
      -- your keymaps here
    })
    
    -- bind a single command
    require('legendary').bind_command(command)
    -- bind a list of commands
    require('legendary').bind_commands({
      -- your commands here
    })
    
    -- bind single or multiple augroups and/or autocmds
    -- these all use the same function
    require('legendary').bind_autocmds(augroup)
    require('legendary').bind_autocmds(autocmd)
    require('legendary').bind_autocmds({
      -- your augroups and autocmds here
    })
<


LUA HELPERS FOR CREATING MAPPINGS ~

When creating keymaps to Lua functions, the Lua expressions are evaluated at
the time they are bound. This means you typically need to pass a function
_reference_ instead of calling the function. For example, you probably want to
map `vim.lsp.buf.formatting_sync`, _not_ `vim.lsp.buf.formatting_sync()`.

If you need to pass arguments to a function when itâ€™s called, you can use the
`lazy` helper:

>
    -- lazy() takes the first argument (a function)
    -- and calls it with the rest of the arguments
    require('legendary.helpers').lazy(vim.lsp.buf.formatting_sync, nil, 1500)
    -- this will *return a new function* defined as:
    function()
      vim.lsp.buf.formatting_sync(nil, 1500)
    end
<


If you need to call a function from a plugin, but do not want the require that
the plugin be loaded at the time you define your keymaps (like if youâ€™re
using Packer to lazy-load plugins), you can use the `lazy_required_fn` helper:

>
    -- lazy_required_fn() takes a module path as the first argument,
    -- a function name from that module as the second argument,
    -- and returns a new function that calls the function by name
    -- with the rest of the arguments
    require('legendary.helpers').lazy_required_fn('telescope.builtin', 'oldfiles', { only_cwd = true })
    -- this will *return a new function* defined as:
    function()
      require('telescope.bulitin')['oldfiles']({ only_cwd = true })
    end
<


If you want to create a keymap that creates a split pane, then does something
in the new pane, there are helpers for that too:

>
    -- split_then() and vsplit_then() both take a Lua function as the
    -- only parameter, and return a new function that creates a
    -- horizontal or vertical split, then calls the specified Lua function
    require('legendary.helpers').split_then(vim.lsp.buf.definition)
    -- this will *return a new function* defined as:
    function()
      vim.cmd('sp')
      vim.lsp.buf.definition()
    end
    
    -- and likewise, this:
    require('legendary.helpers').vsplit_then(vim.lsp.buf.definition)
    -- will *return a new function* defined as:
    function()
      vim.cmd('vsp')
      vim.lsp.buf.definition()
    end
<


UTILITIES                                                *legendary-utilities*

`legendary.nvim` also provides some utilities for developing Lua keymaps,
commands, etc. The following commands are available once `legendary.nvim` is
loaded:


- `:LegendaryScratch` - create a scratchpad buffer to test Lua snippets in
- `:LegendaryEvalLine` - evaluate the current line as a Lua expression
- `:LegendaryEvalLines` - evaluate the line range selected in visual mode as a Lua snippet
- `:LegendaryEvalBuf` - evaluate the entire current buffer as a Lua snippet


Any `return` value from evaluated Lua is printed to the command area.

SORTING ~

`legendary.nvim` will set `kind` to `legendary-keymaps`, `legendary-commands`,
`legendary-autocmds`, or `legendary-items`, depending on whether you are
searching keymaps, commands, autocmds, or all.

You can use to override the sorter used for `legendary.nvim` in your
`vim.ui.select()` handler (for example, dressing.nvim
<https://github.com/stevearc/dressing.nvim> has a `get_config` option to do
this).

The individual items will have `kind = 'legendary-keymap'`, `kind =
'legendary-command`, or `kind = 'legendary-autocmd`, depending on whether it is
a keymap, command, or autocmd.

Generated by panvimdoc <https://github.com/kdheepak/panvimdoc>

vim:tw=78:ts=8:noet:ft=help:norl:
